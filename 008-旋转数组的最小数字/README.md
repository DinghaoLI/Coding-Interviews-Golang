# 题意

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减序列的一个旋转，输出旋转数组的最小元素。

例如

>数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，

该数组的最小值为1。

## 解题思路

和二分查找法一样，用两个指针分别指向数组的第一个元素和最后一个元素。

我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还可以注意到最小的元素刚好是这两个子数组的分界线。

我们试着用二元查找法的思路在寻找这个最小的元素。

首先我们用两个指针，分别指向数组的第一个元素和最后一个元素。按照题目旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对，还有特例。后面再讨论特例）。

接着我们得到处在数组中间的元素

- 如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。

此时数组中最小的元素应该位于该中间 元素的后面。我们可以把第一指针指向该中间元素，这样可以缩小寻找的范围。

- 同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。我们可以把第二个指针指向该中间元素，这样同样可以缩小寻找的范围。我们接着再用更新之后的 两个指针，去得到和比较新的中间元素，循环下去。

## 特殊

我们考虑下特殊情况，我们的循环判断是以rotateArray[low] >= rotateArray[high]为条件的，不满足这个的特殊情况有那些呢？

由于是把递增排序数组前面的若干个数据搬到后面去，因此第一个数字总是大于或者等于最后一个数字，但按照定义还有一个

特例：开始时就rotateArray[low] < rotateArray[high]，那么循环不会执行

如果数组旋转后仍然有序，即rotateArray[low] < rotateArray[high]
如果把排序数组前面0个元素搬到后面，也就是说其实没有旋转，

那么第0个元素就是最小的元素

因此我们将mid初始化为0

现在可以了么，有没有特殊情况仍然未被处理的，

如果rotateArray[low] = rotateArray[high]

> 测试用例: [1, 0, 1, 0, 1, 1]
> 对应输出应该为:
> 0
> 你的输出为:
> 1

此时

> rotateArray[low] rotateArray[mid] rotateArray[high]三者相等
> 无法确定中间元素是属于前面还是后面的递增子数组
> 只能顺序查找